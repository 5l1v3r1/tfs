\documentclass[11pt,a4paper]{report}

\usepackage{amsmath,amsfonts,amssymb,hyperref,graphicx}

\title{
    \centering{\includegraphics[scale=0.2]{icon.png}}\\
    Specification of the On-Disk Format of The TFS File System
}
\author{TFS team}
\date{\today}

% Constants
\newcommand{\versionnumber}{0 }
\newcommand{\clustersize}{4104 }
\newcommand{\pagesize}{4096 }

\begin{document}
    \maketitle
    \begin{abstract}
        We give a complete specification of the on-disk representation of the
        TFS file system. Certain implementation details are covered.
    \end{abstract}

    \chapter{Disk header}
    The first \clustersize bytes are reserved for the ``disk header'' which
    contains configuration and information about the state.

    \section{Introducer}
        \subsection{Magic number (0-8)}
        The first 8 bytes are reserved for a magic number, which is used for
        determining if it does indeed store TFS. It is specified to store the
        string ``\texttt{TFS fmt }'' (note the space) in ASCII.

        If the format does only partially conform to this specification, the
        string ``\texttt{\textasciitilde TFS fmt}'' is used instead.

        \subsection{Version number (8-12)}
        Byte 8 to 12 stores a version number, in little-endian. By this
        revision, said number is \versionnumber.

        Breaking changes will increment the higher half of this number.

        \subsection{Implementation ID (12-20)}
        Byte 12 to 20 stores some UTF-8 sequence specifying what implementation
        it was last read/written with. By setting this field, the
        implementation explicitly states that it was capable of fully or
        partially reading the image.

        The recommended format is the original author's name truncated
        followed by the year of the initial release.

        \subsection{Implementation defined (12-32)}
        Byte 12 to 32 are implementation defined introduction values.

    \section{Options}
        \subsection{Encryption algorithm (32-34)}
        \label{config:encryption}
        Byte 36 to 40 stores a number in little-endian defining encryption
        algorithm in use. It takes following values

        \begin{description}
            \item [$0$] No encryption (identity function).
            \item [$1$] ChaCha20/Poly1305 as described in
                \href{https://tools.ietf.org/html/rfc4253}{RFC \#4253}.
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        \subsection{Checksum algorithm (34-36)}
        \label{config:checksum}
        Byte 32 to 34 stores a number in little-endian defining checksum
        algorithm in use.

        \begin{description}
            \item [$0$] Constant checksum as described
                in~\ref{checksum:constant}.
            \item [$1$] The SeaHash algorithm as described
                in~\ref{checksum:seahash}
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        \subsection{Compression algorithm (36-38)}
        \label{config:compression}
        Byte 34 to 36 stores a number in little-endian defining compression
        algorithm in use.

        \begin{description}
            \item [$0$] No compression (identity function).
            \item [$1$] The LZ4 compressor as described
                in~\ref{compression:lz4}.
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        The exact semantics of encryption is described in~\ref{encryption}

        \subsection{Implementation defined (256-512)}
        Byte 256 to 512 are implementation defined configuration values.

    \section{State}
        \subsection{Head freelist pointer (512-520)}
        Byte 512 to 520 stores some number (in little endian), which takes
        values

        \begin{description}
            \item [$n = 0$]    no free, allocatable cluster.
            \item [$n \neq 0$] the $n$'th cluster is free and conforms
                to~\ref{cluster:metacluster}.
        \end{description}

        \subsection{Super-page pointer (520-528)}
        Byte 520 to 528 stores some number (in little endian), which takes
        values

        \begin{description}
            \item [$n = 0$]    super-page uninitialized.
            \item [$n \neq 0$] the $n$'th page is the super-page as
                defined in~\ref{fs:superpage}.
        \end{description}

        \subsection{Implementation defined (1024-2048)}
        Byte 1024 to 2048 are implementation defined state values.

    \section{Redundancy}
    \label{section:redundant}
        \subsection{Redundant duplicate}
        The header is then repeated once (in byte 2048 to 4096).

        \subsection{Padding}
        Byte 4096 to \clustersize is used as padding to achieve the cluster
        size. It is specified to be zeros.

    \chapter{Disk IO}

    \section{Clusters and pages}
        The disk is divided into clusters of \clustersize bytes each.

        \subsection{Cluster format}
        Each cluster has a header of 8 bytes:

        \begin{description}
            \item [32-bit checksum] This is the 32 last bits of the
                little-endian checksum of the cluster (algorithm
                chosen in~\ref{config:checksum}). The first 4 bytes of
                the cluster are not included in the checksum.
            \item [1 byte page flags] Defines which pages the cluster contains.
                If a bit flag is set, the respective page is contained (as
                compressed) in the cluster. If no flags are set, the cluster is
                uncompressed (i.e.\ represents the page without any special
                representation). The first page flag is the least-significant
                digit and counting up.
            \item [3 bytes for implementation defined usage] This is
                left to the implementation\footnote{Our implementation
                uses it as garbage collection flag for mark-and-sweep.}.
        \end{description}

        This is followed by the number of set page flags in pages compressed.
        The pages (which are \pagesize byte buffers) are concatenated and
        compressed by the algorithm defined by~\ref{config:compression}.

        The $n$'th page in some cluster is found by counting the number of set
        flags in the first $n$ bits of the page flags. Call this value $p$,
        then the page is defined as the bytes from $\pagesize p$ to $\pagesize
        (p + 1)$ of the decompressed cluster.

        A cluster can contain up to 8 pages, and the pages are enumerated
        similarly to clusters. The first 61 bits defines what cluster the page
        is stored in. The last 3 bits defines the index of the page in the
        cluster.

        The whole cluster is encrypted by the algorithm specified
        in~\ref{config:encryption}.

        \subsection{Meta-clusters}
        \label{cluster:metacluster}
        The head of the freelist is a metacluster, which itself is a collection
        of other free clusters. Similarly to used clusters, metaclusters
        contain a 8 byte header:

        \begin{description}
            \item [32-bit checksum] This is the 32 last bits of the
                little-endian checksum of the metacluster (algorithm chosen
                in~\ref{config:checksum}). The first 4 bytes of the cluster are
                not included in the checksum.
            \item [16-bit cluster counter] This 16-bit little-endian integer
                defines the number of free clusters stored in the data section.
                Call this value $n$.
            \item [2 bytes for implementation defined usage] This is
                left to the implementation.
        \end{description}

        This is followed by $n$ 64-bit little-endian pointers to other free
        clusters.

        The first pointer is either a null pointer, meaning that there are no
        more free clusters, or non-null, in which case it points to another
        metacluster\footnote{Popping a cluster is often done by decrementing
        $n$ and returning the respective pointer, unless $n = 0$, which means
        that the head pointer is set to the next metacluster and the current
        metacluster is returned.}.

        Although not a requirement, it is generally recommended that
        the freelist is kept as monotone as possible\footnote{That is,
        sequential allocations should be local as often as possible in
        order to improve compression ratio.}.

        \subsection{Allocation and deallocation}
        The algorithm for allocation and deallocation is implementation
        defined\footnote{It is generally done by inspecting the head of the
            freelist before popping it, to see if it has a sister cluster,
            where the page can be fit in. If it cannot, the freelist is popped.
            The way such clusters are paired is up to the implementation.
            Bijective maps are recommended for optimal performance.}.

    \section{Checksums}
        \subsection{Constant checksum}
        \label{checksum:seahash}
        Constant checksum is independent of the input\footnote{This is used as
        an alternative to storing no checksum, which would make implementation
        harder. Instead, this allows some -- but weak -- protection against failure
        with virtually no effort.}, yielding a constant value,

        $$c = 2^{32} - 1$$

        \subsection{SeaHash}
        \label{checksum:seahash}
        SeaHash's initial state is

        \begin{align*}
            a &= \texttt{16f11fe89b0d677c}_{16} \\
            b &= \texttt{b480a793d8e6c86c}_{16} \\
            c &= \texttt{6fe2e5aaf078ebc9}_{16} \\
            d &= \texttt{14f994a4c5259381}_{16}
        \end{align*}

        The input is broken into chunks of 32 bytes, or 4 64-bit little-endian
        integers. Call these integers $(p, q, r, s)$ respectively. Then
        updating state is defined by

        \begin{align*}
            a' &\equiv f(a + p) \pmod{2^{64}} \\
            b' &\equiv f(b + q) \pmod{2^{64}} \\
            c' &\equiv f(c + r) \pmod{2^{64}} \\
            d' &\equiv f(d + s) \pmod{2^{64}}
        \end{align*}

        with $f(n)$ defined by

        \begin{align*}
            k      &=      \texttt{7ed0e9fa0d94a33}_{16} \\
            f_1(n) &=      n \oplus (x \gg 32) \\
            f_2(n) &\equiv kn \pmod{2^{64}} \\
            f(n)   &=      f_1(f_2(f_1(f_2(f_1(n)))))
        \end{align*}

        The final hash value is then produced by

        $$h \equiv a + f(b) + f(c + f(d)) \pmod{2^{64}}$$

        If a byte, $e$, is excessive (i.e.\ the length is not divisible by 32),
        it is included through

        $$h' \equiv f(h + e) \pmod{2^{64}}$$

        This process is repeated, until no more excessive bytes are left.

    \section{Compression algorithms}
        \subsection{LZ4}
        \label{compression:lz4}
        LZ4 compressed data is a series of blocks, subject to following format:

        \begin{description}
            \item [1 byte token] Call the higher 4 bits $t_1$ and the lower $t_2$.
            \item [$n_1$ 255s (skip if $t_1 \neq 15$)]
            \item [1 byte (skip if $t_1 \neq 15$)] Call this value $e_1$.
            \item [$t_1 + 256n_1 + e_1$ bytes] This (called the literals
                section) is copied directly to the output buffer without any
                pre processing.
            \item [16-bit little-endian integer] Call this value $o$.
            \item [$n_2$ 255s (skip if $t_2 \neq 15$)]
            \item [1 byte (skip if $t_2 \neq 15$)] Call this value $e_1$.
        \end{description}

        After the literals section has been copied to the output buffer, assume
        that the output buffer is now of length $l$ bytes. Then, the bytes from
        $l - O$ to $l - O + t_2 + 256n_2 + e_2$ in the decoded buffer is
        appended to the output stream itself.

        The last block in a stream can be ended after literals
        section, such that no duplicates part is needed.

    \section{Encryption}
    \label{encryption}
        If enabled (see~\ref{config:encryption}), every cluster is encrypted.

        Encrypting cluster $n$ is done by obtaining a
        key\footnote{Equivalently, prepending the 64-bit integer defining which
        cluster is being encrypted, to some user-specified key.} $k' = 2^{64}k
        + n$ and encrypting the cluster with said key by the algorithm given
        in~\ref{config:encryption}.
\end{document}
