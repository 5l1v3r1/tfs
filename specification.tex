\documentclass[11pt,a4paper]{report}

\usepackage{amsmath,amsfonts,amssymb,hyperref,graphicx}

\title{
    \centering{\includegraphics[scale=0.2]{icon.png}}\\
    Specification of the On-Disk Format of The TFS File System
}
\author{TFS team}
\date{\today}

% Constants
\newcommand{\versionnumber}{0 }
\newcommand{\clustersize}{4104 }
\newcommand{\pagesize}{4096 }
\newcommand{\diskheadersize}{64 }

\begin{document}
    \maketitle
    \begin{abstract}
        We give a complete specification of the on-disk representation of the
        TFS file system. Certain implementation details are covered.
    \end{abstract}

    \chapter{Introduction}
    This specification should detail the TFS file system such that it can be
    implemented without ambiguity. As such, it should bridge various
    implementation under one united on-disk format.

    It will not, however, provide the algorithms used to manipulate this format
    efficiently. It will only specify it's static, disk format.

    \section{Assumptions and guarantees}
        TFS provides following guarantees:

        \begin{itemize}
            \item Unless data corruption happens, the disk should never be in
                an inconsistent state. Poweroff and the alike should not affect
                the system such that it enters an invalid or inconsistent
                state.
        \end{itemize}

        Provided that following premises hold:

        \begin{itemize}
            \item Up to 16 bytes can be written atomically, i.e.\ that it is
                never partially written, and interrupting the write will never
                render the disk in a state in which it not already is written
                or retaining the old data.
        \end{itemize}



    \chapter{Disk header}
    The first \diskheadersize bytes are reserved for the ``disk header'' which
    contains unencrypted configuration and information about the state.

    \section{Introducer}
        \subsection{Magic number (byte 0-8)}
        The first 8 bytes are reserved for a magic number, which is used for
        determining if it does indeed store TFS. It is specified to store the
        string ``\texttt{TFS fmt }'' (note the space) in ASCII.

        If the format does only partially conform to this specification, the
        string ``\texttt{\textasciitilde TFS fmt}'' is used instead.

        \subsection{Version number (byte 8-12)}
        \label{header:versionnumber}
        This field stores a version number, in little-endian. By this revision,
        said number is \versionnumber.

        Breaking changes will increment the higher half of this number.

        \subsection{Version number, repeated (byte 12-16)}
        Repetition of~\ref{header:versionnumber}.

        \subsection{Implementation ID (byte 16-24)}
        \label{header:implementationid}
        This field stores some UTF-8 sequence specifying what implementation it
        was last read/written with. By setting this field, the implementation
        explicitly states that it was capable of fully or partially reading the
        image.

        The recommended format is the original author's name truncated
        followed by the year of the initial release.

        \subsection{Implementation ID, repeated (byte 24-32)}
        Repetition of~\ref{header:implementationid}.

    \section{Encryption}
        \subsection{Encryption algorithm (byte 32-34)}
        \label{header:encryption}
        This field stores a number in little-endian defining encryption
        algorithm in use. It takes following values

        \begin{description}
            \item [$0$] No encryption (identity function).
            \item [$1$] SPECK-256/BLAKE2s key stretching and fingerprint.
                See~\ref{crypto:speck}.
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        Every encryption algorithm must have two components in it. A class of
        cipher functions,

        \begin{align*}
            c_{b, k}      &: \{0, 1\}^b \times \{0, 1\}^k \to \{0, 1\}^b \\
            c_{b, k}^{-1} &: \{0, 1\}^b \times \{0, 1\}^k \to \{0, 1\}^b
        \end{align*}

        and a class of password fingerprint functions (see~\ref{header:fingerprint}):

        $$f_k : \{0,1\}^k \to \{0,1\}^{32}$$

        \subsection{Encryption algorithm, repeated (byte 34-36)}
        Repetition of~\ref{header:encryption}.

        \subsection{Password fingerprint (byte 36-40)}
        \label{header:fingerprint}
        This field stores a little-endian integer whose value is dependent on
        the key and the encryption algorithm that is used
        (see~\ref{header:encryption}). In particular, the algorithm must
        specify a function to derive a 4 byte number from an arbitrary string.
        If this string matches the password, the number stored in this field
        should match. Its purpose is to be able to detect wrong passwords.

        \subsection{Password fingerprint, repeated (byte 40-44)}
        Repetition of~\ref{header:fingerprint}.

    \chapter{Configuration and state}
    Following the header, a \clustersize bytes segment containing the
    configuration and state is stored, and is stored encrypted with the
    encryption method specified in~\ref{header:encryption}.

    For convenience, from now on, we will enumerate the bytes with $0$ mapping
    to the start of this segment (in absolute values, byte \diskheadersize). As
    such, any address is considered relative to this.

    \section{Configuration}
        \subsection{Checksum algorithm (byte 0-2)}
        \label{config:checksum}
        This field stores a number in little-endian defining checksum algorithm
        in use.

        \begin{description}
            \item [$0$] Constant checksum as described
                in~\ref{checksum:constant}.
            \item [$1$] The SeaHash algorithm as described
                in~\ref{checksum:seahash}
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        \subsection{Compression algorithm (byte 2-4)}
        \label{config:compression}
        This field stores a number in little-endian defining compression
        algorithm in use.

        \begin{description}
            \item [$0$] No compression (identity function).
            \item [$1$] The LZ4 compressor as described
                in~\ref{compression:lz4}.
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        The exact semantics of encryption is described in~\ref{encryption}

    \section{State}
        \subsection{Head freelist pointer (byte 32-40)}
        This field stores some number (in little endian), which takes values

        \begin{description}
            \item [$n = 0$]    no free, allocatable cluster.
            \item [$n \neq 0$] the $n$'th cluster is free and conforms
                to~\ref{cluster:metacluster}.
        \end{description}

        \subsection{Super-page pointer (byte 40-48)}
        This field stores some number (in little endian), which takes values

        \begin{description}
            \item [$n = 0$]    super-page uninitialized.
            \item [$n \neq 0$] the $n$'th page is the super-page as
                defined in~\ref{fs:superpage}.
        \end{description}

    \chapter{Disk IO}

    \section{Clusters and pages}
        The disk is divided into clusters of \clustersize bytes each.

        \subsection{Cluster format}
        Each cluster has a header of 8 bytes:

        \begin{description}
            \item [32-bit checksum] This is the 32 last bits of the
                little-endian checksum of the cluster (algorithm
                chosen in~\ref{config:checksum}). The first 4 bytes of
                the cluster are not included in the checksum.
            \item [1 byte page flags] Defines which pages the cluster contains.
                If a bit flag is set, the respective page is contained (as
                compressed) in the cluster. If no flags are set, the cluster is
                uncompressed (i.e.\ represents the page without any special
                representation). The first page flag is the least-significant
                digit and counting up.
            \item [3 bytes for implementation defined usage] This is
                left to the implementation\footnote{Our implementation
                uses it as garbage collection flag for mark-and-sweep.}.
        \end{description}

        This is followed by the number of set page flags in pages compressed.
        The pages (which are \pagesize byte buffers) are concatenated and
        compressed by the algorithm defined by~\ref{config:compression}.

        The $n$'th page in some cluster is found by counting the number of set
        flags in the first $n$ bits of the page flags. Call this value $p$,
        then the page is defined as the bytes from $\pagesize p$ to $\pagesize
        (p + 1)$ of the decompressed cluster.

        A cluster can contain up to 8 pages, and the pages are enumerated
        similarly to clusters. The first 61 bits defines what cluster the page
        is stored in. The last 3 bits defines the index of the page in the
        cluster.

        \subsection{Meta-clusters}
        \label{cluster:metacluster}
        The head of the freelist is a metacluster, which itself is a collection
        of other free clusters. Similarly to used clusters, metaclusters
        contain a 8 byte header:

        \begin{description}
            \item [32-bit checksum] This is the 32 last bits of the
                little-endian checksum of the metacluster (algorithm chosen
                in~\ref{config:checksum}). The first 4 bytes of the cluster are
                not included in the checksum.
            \item [16-bit cluster counter] This 16-bit little-endian integer
                defines the number of free clusters stored in the data section.
                Call this value $n$.
            \item [2 bytes for implementation defined usage] This is
                left to the implementation.
        \end{description}

        This is followed by $n$ 64-bit little-endian pointers to other free
        clusters.

        The first pointer is either a null pointer, meaning that there are no
        more free clusters, or non-null, in which case it points to another
        metacluster\footnote{Popping a cluster is often done by decrementing
        $n$ and returning the respective pointer, unless $n = 0$, which means
        that the head pointer is set to the next metacluster and the current
        metacluster is returned.}.

        Although not a requirement, it is generally recommended that
        the freelist is kept as monotone as possible\footnote{That is,
        sequential allocations should be local as often as possible in
        order to improve compression ratio.}.

        \subsection{Allocation and deallocation}
        The algorithm for allocation and deallocation is implementation
        defined\footnote{It is generally done by inspecting the head of the
            freelist before popping it, to see if it has a sister cluster,
            where the page can be fit in. If it cannot, the freelist is popped.
            The way such clusters are paired is up to the implementation.
            Bijective maps are recommended for optimal performance.}.

    \section{Checksums}
        \subsection{Constant checksum}
        \label{checksum:seahash}
        Constant checksum is independent of the input\footnote{This is used as
        an alternative to storing no checksum, which would make implementation
        harder. Instead, this allows some -- but weak -- protection against failure
        with virtually no effort.}, yielding a constant value,

        $$c = 2^{32} - 1$$

        \subsection{SeaHash}
        \label{checksum:seahash}
        SeaHash's initial state is

        \begin{align*}
            a &= \texttt{16f11fe89b0d677c}_{16} \\
            b &= \texttt{b480a793d8e6c86c}_{16} \\
            c &= \texttt{6fe2e5aaf078ebc9}_{16} \\
            d &= \texttt{14f994a4c5259381}_{16}
        \end{align*}

        The input is broken into chunks of 32 bytes, or 4 64-bit little-endian
        integers. Call these integers $(p, q, r, s)$ respectively. Then
        updating state is defined by

        \begin{align*}
            a' &\equiv f(a + p) \pmod{2^{64}} \\
            b' &\equiv f(b + q) \pmod{2^{64}} \\
            c' &\equiv f(c + r) \pmod{2^{64}} \\
            d' &\equiv f(d + s) \pmod{2^{64}}
        \end{align*}

        with $f(n)$ defined by

        \begin{align*}
            k      &=      \texttt{7ed0e9fa0d94a33}_{16} \\
            f_1(n) &=      n \oplus (x \gg 32) \\
            f_2(n) &\equiv kn \pmod{2^{64}} \\
            f(n)   &=      f_1(f_2(f_1(f_2(f_1(n)))))
        \end{align*}

        The final hash value is then produced by

        $$h \equiv a + f(b) + f(c + f(d)) \pmod{2^{64}}$$

        If a byte, $e$, is excessive (i.e.\ the length is not divisible by 32),
        it is included through

        $$h' \equiv f(h + e) \pmod{2^{64}}$$

        This process is repeated, until no more excessive bytes are left.

    \section{Compression algorithms}
        \subsection{LZ4}
        \label{compression:lz4}
        LZ4 compressed data is a series of blocks, subject to following format:

        \begin{description}
            \item [1 byte token] Call the higher 4 bits $t_1$ and the lower $t_2$.
            \item [$n_1$ 255s (skip if $t_1 \neq 15$)]
            \item [1 byte (skip if $t_1 \neq 15$)] Call this value $e_1$.
            \item [$t_1 + 256n_1 + e_1$ bytes] This (called the literals
                section) is copied directly to the output buffer without any
                pre processing.
            \item [16-bit little-endian integer] Call this value $o$.
            \item [$n_2$ 255s (skip if $t_2 \neq 15$)]
            \item [1 byte (skip if $t_2 \neq 15$)] Call this value $e_1$.
        \end{description}

        After the literals section has been copied to the output buffer, assume
        that the output buffer is now of length $l$ bytes. Then, the bytes from
        $l - O$ to $l - O + t_2 + 256n_2 + e_2$ in the decoded buffer is
        appended to the output stream itself.

        The last block in a stream can be ended after literals
        section, such that no duplicates part is needed.
\end{document}
