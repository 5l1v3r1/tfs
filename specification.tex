\documentclass[11pt,a4paper]{report}

\usepackage{amsmath,amsfonts,amssymb,hyperref,graphicx}

\title{
    \centering{\includegraphics[scale=0.2]{icon.png}}\\
    Specification of the On-Disk Format of The TFS File System
}
\author{TFS team}
\date{\today}

% Constants
\newcommand{\clusterheader}{8 }
\newcommand{\clustersize}{4096 }
\newcommand{\maxpagesincluster}{16 }
\newcommand{\minimumsectorsize}{512 }
\newcommand{\pagesize}{4090 }
\newcommand{\versionnumber}{0 }

% Math
\newcommand{\concat}{\Vert}

\begin{document}
    \maketitle
    \begin{abstract}
        We give a complete specification of the on-disk representation of the
        TFS file system. Certain implementation details are covered.
    \end{abstract}

    \chapter{Introduction}
    This specification should detail the TFS file system such that it can be
    implemented without ambiguity. As such, it should bridge various
    implementation under one united on-disk format.

    It will not, however, provide the algorithms used to manipulate this format
    efficiently. It will only specify it's static, disk format.

    \section{Assumptions and guarantees}
    \label{assumptions_guarantees}
        TFS provides following guarantees:

        \begin{itemize}
            \item Unless data corruption happens, the disk should never be in
                an inconsistent state\footnote{TFS achieves this without using
                journaling or a transactional model.}. Poweroff and the alike
                should not affect the system such that it enters an invalid or
                inconsistent state.
        \end{itemize}

        Provided that following premises hold:

        \begin{itemize}
            \item $n$ bytes can be written atomically if $n$ divides
                \minimumsectorsize\footnote{Any disks on the market today has
                sector size of \minimumsectorsize bytes or a multiple thereof,
                hence the choice of this value.} and $n < \minimumsectorsize$,
                i.e.\ it is never partially written, and interrupting the
                write will never render the disk in a state in which it not already
                is written or retaining the old data.
        \end{itemize}

    \chapter{Disk header}
    The first \minimumsectorsize bytes are reserved for the ``disk header''
    which contains unencrypted configuration and information about the state.

    \section{Introducer}
        \subsection{Magic number (byte 0-8)}
        The first 8 bytes are reserved for a magic number, which is used for
        determining if it does indeed store TFS. It is specified to store the
        string ``\texttt{TFS fmt }'' (note the space) in ASCII.

        If the format does only partially conform to this specification, the
        string ``\texttt{\textasciitilde TFS fmt}'' is used instead.

        \subsection{Version number (byte 8-12)}
        \label{header:versionnumber}
        This field stores a version number, in little-endian. By this revision,
        said number is \versionnumber.

        Breaking changes will increment the higher half of this number.

        \subsection{Version number, repeated (byte 12-16)}
        Repetition of~\ref{header:versionnumber}.

        \subsection{Implementation ID (byte 16-24)}
        \label{header:implementationid}
        This field stores some UTF-8 sequence specifying what implementation it
        was last read/written with. By setting this field, the implementation
        explicitly states that it was capable of fully or partially reading the
        image.

        The recommended format is the original author's name truncated
        followed by the year of the initial release.

        \subsection{Implementation ID, repeated (byte 24-32)}
        Repetition of~\ref{header:implementationid}.

    \section{Encryption}
        \subsection{Encryption algorithm (byte 32-34)}
        \label{header:encryption}
        This field stores a number in little-endian defining encryption
        algorithm in use. It takes following values

        \begin{description}
            \item [$0$] No encryption (identity function).
            \item [$1$] SPECK-256 with BLAKE2s key stretching (XEX mode).
                See~\ref{crypto:speck}.
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        \subsection{Encryption algorithm, repeated (byte 34-36)}
        Repetition of~\ref{header:encryption}.

    \chapter{State segment}
    Following the header, a \clustersize bytes segment containing the
    configuration and state is stored, and is stored encrypted with the
    encryption method specified in~\ref{header:encryption}.

    For convenience, from now on, we will enumerate the bytes with $0$ mapping
    to the start of this segment (in absolute values, byte \minimumsectorsize).
    As such, any address is considered relative to this.

    \section{Fixed}
        \subsection{Zeros (byte 0-4)}
        These bytes are zero. They are used to make sure the password was
        correctly given and the decryption was correct.

    \section{Configuration}
        \subsection{Checksum algorithm (byte 16-18)}
        \label{config:checksum}
        This field stores a number in little-endian defining checksum algorithm
        in use.

        \begin{description}
            \item [$0$] Constant checksum as described
                in~\ref{checksum:constant}.
            \item [$1$] The SeaHash algorithm as described
                in~\ref{checksum:seahash}
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        \subsection{Compression algorithm (byte 18-20)}
        \label{config:compression}
        This field stores a number in little-endian defining compression
        algorithm in use.

        \begin{description}
            \item [$0$] No compression (identity function).
            \item [$1$] The LZ4 compressor as described
                in~\ref{compression:lz4}.
            \item [$\geq 2^{15}$] Implementation defined.
        \end{description}

        In order to provide the guarantees given
        in~\ref{assumptions_guarantees}, one constraint\footnote{It is
        necessary because it allows first writing and then extending the
        cluster, i.e.\ no data is corrupted on poweroff.  This is achieved
        by most algorithms relevant for this usecase (particularly
        streaming dictionary coders and adaptive entropy coders).} is put to
        the compressions algorithms: It should be possible to extend the input
        by appending some sequence of bytes to the compressed data, or

        $$\forall x, y \  \exists k \quad x = c^{-1}(x') \implies x \concat y = c^{-1}(x' \concat k)$$

    \section{State}
        \subsection{Head freelist pointer (byte 32-40)}
        This field stores some number (in little-endian), which takes values

        \begin{description}
            \item [$n = 0$]    no free, allocatable cluster.
            \item [$n \neq 0$] the $n$'th cluster is free and conforms
                to~\ref{cluster:metacluster}.
        \end{description}

        \subsection{Super-page pointer (byte 40-48)}
        This field stores some number (in little-endian), which takes values

        \begin{description}
            \item [$n = 0$]    super-page uninitialized.
            \item [$n \neq 0$] the $n$'th page is the super-page as
                defined in~\ref{fs:superpage}.
        \end{description}

    \section{Integrity checking}
        \subsection{Checksum (byte 40-44)}
        This field stores a little-endian integer equal to the checksum of the
        state segment (excluding this field), calculated by the algorithm
        specified in~\ref{config:checksum}.

    \chapter{Disk IO}

    \section{Clusters and pages}
        The disk is divided into clusters of \clustersize bytes each.

        \subsection{Cluster format}
        Each cluster has a header of \clusterheader bytes:

        \begin{description}
            \item [32-bit checksum] This is the 32 last bits of the
                little-endian checksum of the cluster (algorithm
                chosen in~\ref{config:checksum}). The first 4 bytes of
                the cluster are not included in the checksum.
            \item [16-bit occupied space] This little-endian integer defines
                how much of the cluster is used. Any data in the cluster beyond
                this length is never read and can be freely overwritten.
            \item [2 bytes of implementation defined use] These are left to the
                implementation\footnote{Our implementation uses these for
                mark-and-sweep garbage collection colors.}.
        \end{description}

        A cluster contain up to \maxpagesincluster of \pagesize bytes blocks
        called ``pages''. The decompressed data (algorithm defined
        in~\ref{config:compression}) is the contained pages concatenated.

        Pointers to pages uses the first 60 bits to define the cluster number,
        and the last four bits to define which page, it points to. In
        particular, if $c$ is the cluster number and $p$ is the number of the
        page in the cluster, then the pointer is given by

        $$r = \maxpagesincluster c + p$$

        Allocation is done in implementation defined manner\footnote{Our
        implementation first tries to fit it into the next cluster by
        appending it (all this can be done atomically by updating the
        occupied space field after writing the cluster, see requirements
        in~\ref{config:compression}). If this fails, it proceeds to pop
        from the top of the freelist.}.

        \subsection{Meta-clusters}
        \label{cluster:metacluster}
        The head of the freelist is a metacluster, which itself is a collection
        of other free clusters. Similarly to used clusters, metaclusters
        contain a 8 byte header:

        \begin{description}
            \item [32-bit checksum] This is the 32 last bits of the
                little-endian checksum of the metacluster (algorithm chosen
                in~\ref{config:checksum}). The first 4 bytes of the cluster are
                not included in the checksum.
            \item [16-bit cluster counter] This 16-bit little-endian integer
                defines the number of free clusters stored in the data section.
                Call this value $n$.
            \item [2 bytes for implementation defined usage] This is
                left to the implementation.
        \end{description}

        This is followed by $n$ 64-bit little-endian pointers to other free
        clusters.

        The first pointer is either a null pointer, meaning that there are no
        more free clusters, or non-null, in which case it points to another
        metacluster\footnote{Popping a cluster is often done by decrementing
        $n$ and returning the respective pointer, unless $n = 0$, which means
        that the head pointer is set to the next metacluster and the current
        metacluster is returned.}.

        Although not a requirement, it is generally recommended that
        the freelist is kept as monotone as possible\footnote{That is,
        sequential allocations should be local as often as possible in
        order to improve compression ratio.}.

        \subsection{Allocation and deallocation}
        The algorithm for allocation and deallocation is implementation
        defined\footnote{It is generally done by inspecting the head of the
            freelist before popping it, to see if it has a sister cluster,
            where the page can be fit in. If it cannot, the freelist is popped.
            The way such clusters are paired is up to the implementation.
            Bijective maps are recommended for optimal performance.}.

    \section{Checksums}
        \subsection{Constant checksum}
        \label{checksum:seahash}
        Constant checksum is independent of the input\footnote{This is used as
        an alternative to storing no checksum, which would make implementation
        harder. Instead, this allows some -- but weak -- protection against failure
        with virtually no effort.}, yielding a constant value,

        $$c = 2^{32} - 1$$

        \subsection{SeaHash}
        \label{checksum:seahash}
        SeaHash's initial state is

        \begin{align*}
            a &= \texttt{16f11fe89b0d677c}_{16} \\
            b &= \texttt{b480a793d8e6c86c}_{16} \\
            c &= \texttt{6fe2e5aaf078ebc9}_{16} \\
            d &= \texttt{14f994a4c5259381}_{16}
        \end{align*}

        The input is broken into chunks of 32 bytes, or 4 64-bit little-endian
        integers. Call these integers $(p, q, r, s)$ respectively. Then
        updating state is defined by

        \begin{align*}
            a' &\equiv f(a + p) \pmod{2^{64}} \\
            b' &\equiv f(b + q) \pmod{2^{64}} \\
            c' &\equiv f(c + r) \pmod{2^{64}} \\
            d' &\equiv f(d + s) \pmod{2^{64}}
        \end{align*}

        with $f(n)$ defined by

        \begin{align*}
            k      &=      \texttt{7ed0e9fa0d94a33}_{16} \\
            f_1(n) &=      n \oplus (x \gg 32) \\
            f_2(n) &\equiv kn \pmod{2^{64}} \\
            f(n)   &=      f_1(f_2(f_1(f_2(f_1(n)))))
        \end{align*}

        TODO: Handle excessive bytes (latest update in the seahash algo).

        The final hash value is then produced by

        $$h \equiv a + f(l + b) + f(c + f(d)) \pmod{2^{64}}$$

        (where $l$ is the length)

    \section{Compression algorithms}
        \subsection{LZ4}
        \label{compression:lz4}
        LZ4 compressed data is a series of blocks, subject to following format:

        \begin{description}
            \item [1 byte token] Call the higher 4 bits $t_1$ and the lower $t_2$.
            \item [$n_1$ 255s (skip if $t_1 \neq 15$)]
            \item [1 byte (skip if $t_1 \neq 15$)] Call this value $e_1$.
            \item [$t_1 + 256n_1 + e_1$ bytes] This (called the literals
                section) is copied directly to the output buffer without any
                pre processing.
            \item [16-bit little-endian integer] Call this value $o$.
            \item [$n_2$ 255s (skip if $t_2 \neq 15$)]
            \item [1 byte (skip if $t_2 \neq 15$)] Call this value $e_1$.
        \end{description}

        After the literals section has been copied to the output buffer, assume
        that the output buffer is now of length $l$ bytes. Then, the bytes from
        $l - O$ to $l - O + t_2 + 256n_2 + e_2$ in the decoded buffer is
        appended to the output stream itself.

        The last block in a stream can be ended after literals section, such
        that no duplicates part is needed.
\end{document}
